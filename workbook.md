TIP #1 Importance of knowing every word you read
Has it ever occurred to you that you were reading a block of text that made sense in the beginning, but after you've finished the whole block you had absolutely no idea what was it about? This happens because there was a word in there somewhere which you didn't understand. When we encounter such a word it hinders the comprehension of all the text that follows.
When reading any text, if you see a word that you don't fully understand, STOP. Make sure you look up the meaning of the word, and only then continue, starting from that sentence that contained the unknown word.

TIP #2 Importance of a second opinion
You search online and find a definition of a subject. Great, but don't just copy that definition and be done with it! Different people explain things differently, so it's always worth it to seek out other definitions too. You might find some that resonate with you better. Also, when you have multiple sources, you can synthesise them to a have a definition that describes the subject in your own way.
Interviewers don't really care about hearing the exact textbook definitions, it's much more about how well you can articulate and reason around subjects. They want to hear how you explain things in your own words instead of bone-dry academics.


## Java

### What is the JVM?
`The Java Virtual Machine (JVM) is a virtual machine that executes Java bytecode and provides a runtime environment for Java programs. It is an essential component of the Java ecosystem, as it is responsible for running Java applications on a wide variety of hardware and software platforms.`

`The JVM is implemented in software and is designed to be portable, meaning that it can be implemented on any hardware or operating system that supports it. This allows Java programs to run on a wide variety of devices and systems, including desktops, servers, mobile devices, and embedded systems.`

`The JVM is an abstract computing machine that executes Java bytecode, which is a low-level representation of a Java program. When a Java program is compiled, the Java compiler generates bytecode that can be run on any JVM, regardless of the hardware or operating system on which it is running.`

`The JVM provides a runtime environment that includes a set of core libraries and APIs that provide access to system resources and services, such as networking, I/O, and concurrency. It also provides a set of security features that help to protect against malicious code and ensure the integrity of the runtime environment.`

`Overall, the JVM is an essential component of the Java ecosystem that enables Java programs to run on a wide variety of hardware and software platforms.`
### What does Java compilation mean?
`In the Java programming language, compilation refers to the process of converting a program written in the Java programming language into machine code that can be executed by a computer.`

`When a Java program is compiled, the Java compiler translates the source code of the program into bytecode, which is a low-level representation of the program that can be run on any Java Virtual Machine (JVM). The bytecode is stored in a .class file, which can be executed by the JVM.`

`Compilation is an important part of the development process in Java, as it enables the programmer to catch syntax errors and other issues in the source code before the program is executed. It also allows the programmer to optimize the code for performance and maintainability.`

`Java programs are typically compiled from the command line using the javac command. For example, to compile a program called MyProgram.java, you would use the following command:`

```
javac MyProgram.java
```
`This command would generate a .class file called MyProgram.class that contains the bytecode for the program. The .class file can then be executed by the JVM using the java command.`

`Overall, compilation is a key part of the Java development process, as it enables the programmer to convert the source code of a Java program into machine code that can be executed by the computer.`
### What is Java bytecode?
`Java bytecode is a low-level representation of a Java program that can be executed by the Java Virtual Machine (JVM). It is the intermediate form of a Java program that is generated by the Java compiler and stored in a .class file.`

`Bytecode is a compact, platform-independent representation of a Java program that is designed to be easy to interpret and execute by the JVM. It consists of a set of instructions and data that can be executed by the JVM to perform the actions specified in the source code of the Java program.`

`Bytecode is an important part of the Java ecosystem, as it allows Java programs to be run on a wide variety of hardware and software platforms. Because the JVM is implemented on many different platforms, a Java program compiled into bytecode can be run on any platform that supports the JVM, without the need to recompile the program for each specific platform.`

`To execute a Java program, the JVM loads the .class file containing the bytecode and interprets the bytecode instructions to perform the actions specified in the source code of the program. This process is known as Just-In-Time (JIT) compilation, and it allows the JVM to execute Java programs efficiently on a variety of hardware and software platforms.`

`Overall, Java bytecode is a key part of the Java ecosystem, as it enables Java programs to be run on a wide variety of platforms and enables the JVM to execute Java programs efficiently.`
### What is the difference between the JRE and the JDK?
`The Java Runtime Environment (JRE) and the Java Development Kit (JDK) are two key components of the Java ecosystem. The JRE is a package that contains the necessary libraries and tools to run Java programs, while the JDK is a package that contains the tools and libraries needed to develop Java programs.`

`The main difference between the JRE and the JDK is that the JRE is intended for running Java programs, while the JDK is intended for developing Java programs. The JRE includes the Java Virtual Machine (JVM), the core libraries and APIs, and other tools that are needed to run Java programs. The JDK includes the JRE, as well as a set of development tools, such as the Java compiler and debugger, that are needed to develop Java programs.`

`Here is a summary of the main differences between the JRE and the JDK:`

- `The JRE is a package that contains the necessary libraries and tools to run Java programs, while the JDK is a package that contains the tools and libraries needed to develop Java programs.`
- `The JRE includes the JVM, the core libraries and APIs, and other tools that are needed to run Java programs, while the JDK includes the JRE and a set of development tools, such as the Java compiler and debugger, that are needed to develop Java programs.`
- `The JRE is typically installed on a user's computer to enable them to run Java programs, while the JDK is typically installed on a developer's machine to enable them to develop Java programs.`
`Overall, the JRE and the JDK are two important components of the Java ecosystem that are used for different purposes. The JRE is used to run Java programs, while the JDK is used to develop Java programs.`

## Java Execution flow

### What control statements are available in Java?
`In the Java programming language, control statements are used to control the flow of execution in a program. There are several types of control statements available in Java, including:`

- `Conditional statements: Conditional statements allow you to execute a block of code based on a specific condition. The two main types of conditional statements in Java are the if statement and the switch statement.`

- `Looping statements: Looping statements allow you to execute a block of code repeatedly, based on a specific condition. The main types of looping statements in Java are the for loop, the while loop, and the do-while loop.`

- `Jump statements: Jump statements allow you to transfer control to a different part of the program. The main types of jump statements in Java are the break statement, the continue statement, and the return statement.`

`Here is an example of how these control statements might be used in a Java program:`

```
int i = 0;

// loop through the array
while (i < 10) {
    // check if the value is even
    if (array[i] % 2 == 0) {
        System.out.println(array[i]);
    }
    // increment the counter
    i++;
}

// switch statement
switch (value) {
    case 1:
        // do something
        break;
    case 2:
        // do something else
        break;
    default:
        // do something else
        break;
}

// return statement
return result;
```
`In this example, the while loop iterates through an array and prints out the even values, the switch statement executes a block of code based on the value of a variable, and the return statement ends the current method and returns a value to the caller.`

`Overall, control statements are an important part of programming in Java, and they allow you to control the flow of execution in a program and make decisions based on specific conditions.`
### Compare the different looping constructs in Java.
- `for loop: The for loop is used to execute a block of code a specific number of times. It has the following syntax:`
```
for (initialization; condition; increment/decrement) {
   statement(s)
}
```
 `The initialization section is executed only once at the beginning of the loop. It is used to initialize the loop variables. The condition is evaluated before each iteration of the loop. If the condition is true, the loop body is executed. If the condition is false, the loop terminates. The increment/decrement section is executed at the end of each iteration of the loop and is used to update the loop variables.`
 - `while loop: The while loop is used to execute a block of code as long as a certain condition is true. It has the following syntax:`
 ```
while (condition) {
   statement(s)
}
 ```
 `The condition is evaluated before each iteration of the loop. If the condition is true, the loop body is executed. If the condition is false, the loop terminates.`
 - `do-while loop: The do-while loop is similar to the while loop, but it guarantees that the loop body will be executed at least once. It has the following syntax:`
 ```
do {
   statement(s)
} while (condition);
 ```
 `The loop body is executed first, and then the condition is evaluated. If the condition is true, the loop continues. If the condition is false, the loop terminates.`
 - `enhanced for loop (also known as the "for-each" loop): The enhanced for loop is used to iterate over the elements of an array or a collection. It has the following syntax:`
 ```
for (type element : array/collection) {
   statement(s)
}
 ```
 `The loop iterates over the elements of the array or collection and assigns each element to the variable element in turn. The loop terminates when it has processed all the elements of the array or collection.`
### Compare the different conditional constructs in Java.
- `if statement: The if statement is used to execute a block of code if a certain condition is true. It has the following syntax:`
```
if (condition) {
   statement(s)
}
```

`The condition is evaluated, and if it is true, the block of code within the if statement is executed. If the condition is false, the block of code is skipped.`

- `if-else statement: The if-else statement is used to execute one block of code if a certain condition is true, and another block of code if the condition is false. It has the following syntax:`
```
if (condition) {
   statement(s)
} else {
   statement(s)
}
```

`The condition is evaluated, and if it is true, the block of code within the first set of curly braces is executed. If the condition is false, the block of code within the second set of curly braces is executed.`

- `if-else if-else statement: The if-else if-else statement is used to execute one of several blocks of code, depending on the value of a condition. It has the following syntax:`
```
if (condition1) {
   statement(s)
} else if (condition2) {
   statement(s)
} else {
   statement(s)
}
```
`The condition1 is evaluated first. If it is true, the block of code within the first set of curly braces is executed. If condition1 is false, condition2 is evaluated. If condition2 is true, the block of code within the second set of curly braces is executed. If both condition1 and condition2 are false, the block of code within the third set of curly braces is executed.`

- `switch statement: The switch statement is used to execute one of several blocks of code, depending on the value of an expression. It has the following syntax:`
```
switch (expression) {
   case value1:
      statement(s);
      break;
   case value2:
      statement(s);
      break;
   ...
   default:
      statement(s);
}
```

`The expression is evaluated, and the value is compared to the values specified in each case clause. If a case clause matches the value of the expression, the block of code within that case clause is executed. If none of the case clauses match the value of the expression, the block of code within the default clause is executed. The break statement is used to exit the switch statement and continue execution at the next statement. If the break statement is omitted, execution will continue with the next case clause.`
## Java Type system

### What are primitive types in Java? Give some examples.
`In Java, primitive types are the most basic data types available in the language. They are used to represent simple values like integers, floating-point numbers, and boolean values. There are eight primitive types in Java:`

 - `boolean: The boolean type represents a value that is either true or false.`
- `char: The char type represents a single Unicode character. It is a 16-bit unsigned integer type that can hold any value between 0 and 65,535.`
- `byte: The byte type represents an 8-bit signed integer. It can hold values between -128 and 127.`
- `short: The short type represents a 16-bit signed integer. It can hold values between -32,768 and 32,767.`
- `int: The int type represents a 32-bit signed integer. It is the most commonly used integer type in Java and can hold values between -2,147,483,648 and 2,147,483,647.`
- `long: The long type represents a 64-bit signed integer. It can hold values between -9,223,372,036,854,775,808 and 9,223,372,036,854,775,807.`
- `float: The float type represents a single-precision 32-bit IEEE 754 floating-point number.`
- `double: The double type represents a double-precision 64-bit IEEE 754 floating-point number. It is the most commonly used floating-point type in Java.`
### What is the difference between primitive types and reference types?
- `The basic difference is that primitive variables store the actual values, whereas reference variables store the addresses of the objects they refer to.`
### What is a class in Java?
- `A class — in the context of Java — is a template used to create objects and to define object data types and methods. Classes are categories, and objects are items within each category. All class objects should have the basic class properties.`
### What is an object in Java?
- `A Java object is a member (also called an instance) of a Java class. Each object has an identity, a behavior and a state. The state of an object is stored in fields (variables), while methods (functions) display the object's behavior. Objects are created at runtime from templates, which are also known as classes.`
### What is a constructor?
- `A constructor in Java is a special method that is used to initialize objects. The constructor is called when an object of a class is created. It can be used to set initial values for object attributes. In Java, a constructor is a block of codes similar to the method.`
### What is an enum in Java?
- `An enum type is a special data type that enables for a variable to be a set of predefined constants. The variable must be equal to one of the values that have been predefined for it. Common examples include compass directions (values of NORTH, SOUTH, EAST, and WEST) and the days of the week.`
### What does the var keyword mean?
- `The var keyword in Java is a type inference feature that was introduced in Java 10. It allows the type of a local variable to be inferred from the initializer expression, rather than having to be explicitly declared.`

`For example, consider the following code snippet:`

```
var list = new ArrayList<String>();
```
`In this code, the type of the list variable is inferred to be ArrayList<String>, so it is equivalent to the following code snippet:`

```
ArrayList<String> list = new ArrayList<String>();
```
`The var keyword can be used in any context where a local variable is being declared and initialized, including in for-loop statements, catch clauses, and method declarations. However, it cannot be used as a type for fields, method return types, or formal parameters.`

`Using the var keyword can make your code more concise and easier to read, particularly in cases where the type of a variable is complex or verbose. However, it is important to use it judiciously, as it can also make your code less explicit and potentially harder to understand.`
### Explain the difference between a class and an enum.
`There are several key differences between classes and enums:`

- `Instances: As mentioned earlier, an enum has a fixed number of instances, which are created when the enum type is first initialized. On the other hand, a class can have an unlimited number of instances, which are created using the new operator.`

- `Members: A class can have a wide variety of members, including fields, methods, and constructors. An enum, on the other hand, can only have fields and methods, and it is not allowed to have constructors.`

- `Inheritance: A class can inherit from another class or implement one or more interfaces, which allows you to create a hierarchy of classes and share common behavior. An enum, on the other hand, cannot inherit from other types, and it is implicitly final.`

- `Constant values: An enum has a fixed set of constant values, which are defined as enum constants. A class, on the other hand, does not have any constant values by default, but you can define constant fields by using the static and final keywords.`

`Overall, classes and enums are two different ways of representing data types in Java, and you should choose the one that is most appropriate for your needs. Classes are more flexible and powerful, but they also require more code and are more complex to use. Enums are simpler and easier to use, but they are less flexible and have fewer features.`
### Explain the difference between a class and a record.
`There are several key differences between classes and records:`

- `Syntax: As shown in the examples above, a record is much simpler and more concise than a class, because it does not require you to define any explicit methods or a constructor.`

- `Implicit methods: A record has a set of implicit methods that are generated automatically based on the fields. These methods include equals, hashCode, toString, and accessor methods for each field. These methods are similar to the ones you would define manually in a class, but they are generated automatically and cannot be overridden.`

- `Inheritance: A class can inherit from another class or implement one or more interfaces, which allows you to create a hierarchy of classes and share common behavior. A record, on the other hand, cannot inherit from other types, and it is implicitly final.`

- `Modifiers: A record cannot have any of the following modifiers: abstract, final, native, private, protected, public, static, strictfp, or synchronized.`

`Overall, records are a new and experimental feature in Java, and they are intended to be used for simple data structures that do not require any explicit methods. They are designed to be more concise and easy to use than classes, but they are less flexible and have fewer features. Classes are more powerful and flexible, but they are also more complex and require more code to use.`
### What are interfaces? Why should we use them?
`In Java, an interface is a type that defines a set of abstract methods and constants. An interface does not have any implementation code, but it defines a set of requirements that must be implemented by any class that implements the interface.`

`Interfaces are used to define a common set of behaviors that can be shared by multiple classes. By implementing an interface, a class agrees to implement all of the methods and constants defined in the interface. This allows you to define a set of related behaviors that can be used by any class that implements the interface, regardless of its implementation details.`

`There are several reasons why you might want to use interfaces in your Java code:`

- `Code reuse: By implementing an interface, a class can reuse the methods and constants defined in the interface, which can save you time and effort when writing your code.`

- `Loose coupling: Interfaces allow you to define a set of behaviors that can be used by multiple classes, without the classes being tightly coupled to each other. This makes it easier to change the implementation of a class without affecting the other classes that use it.`

- `Polymorphism: Interfaces allow you to create objects of different types that can all be treated as instances of the interface type. This allows you to write code that is more flexible and can work with different types of objects interchangeably.`

- `Extensibility: Interfaces allow you to define a set of behaviors that can be extended or modified by other classes. This makes it easier to add new functionality to your code without having to change the existing implementation.`

`To create an interface in Java, you use the interface keyword, followed by the name of the interface and a list of abstract methods and constants. Here is an example of an interface definition in Java:`

```
public interface Shape {
   double getArea();
   double getPerimeter();
}
```
`To implement an interface in a class, you use the implements keyword, followed by the name of the interface. The class must then provide an implementation for each of the abstract methods defined in the interface. Here is an example of a class that implements the Shape interface:`

```
public class Circle implements Shape {
   private double radius;

   public Circle(double radius) {
      this.radius = radius;
   }

   public double getArea() {
      return Math.PI * radius * radius;
   }

   public double getPerimeter() {
      return 2 * Math.PI * radius;
   }
}
```
`In summary, interfaces are a powerful feature in Java that allow you to define a set of abstract behaviors that can be shared by multiple classes. They are useful for code reuse, loose coupling, polymorphism, and extensibility, and they are an important part of the object-oriented programming paradigm in Java.`
### What is inheritance?
`In Java, inheritance is a mechanism that allows a class to inherit the properties and behaviors of another class. Inheritance is a fundamental concept in object-oriented programming, and it is used to create a hierarchy of classes that share common behavior.`

`When a class inherits from another class, it is called the "subclass" or "derived class", and the class it inherits from is called the "superclass" or "base class". The subclass inherits all of the fields and methods of the superclass, and it can also define additional fields and methods of its own. This allows the subclass to reuse the code and behavior of the superclass, while also adding its own unique features.`

`Here is an example of inheritance in Java:`

```
public class Animal {
   protected String name;
   protected int age;

   public Animal(String name, int age) {
      this.name = name;
      this.age = age;
   }

   public void eat() {
      System.out.println("Animal is eating.");
   }

   public void sleep() {
      System.out.println("Animal is sleeping.");
   }
}

public class Dog extends Animal {
   private String breed;

   public Dog(String name, int age, String breed) {
      super(name, age);
      this.breed = breed;
   }

   public void bark() {
      System.out.println("Dog is barking.");
   }
}
```
`In this example, the Dog class is a subclass of the Animal class, and it inherits all of the fields and methods of the Animal class. The Dog class also defines an additional field called breed and an additional method called bark.`

`To create a subclass in Java, you use the extends keyword, followed by the name of the superclass. The subclass must then provide an implementation for any abstract methods defined in the superclass. If the superclass has a constructor, the subclass must also call the superclass constructor using the super keyword.`

`Inheritance is a powerful feature in Java, because it allows you to create a hierarchy of classes that share common behavior. It also allows you to create specialized subclasses that inherit the behavior of a more general superclass, and add their own unique features. However, it is important to use inheritance judiciously, as it can also make your code more complex and harder to maintain.`
### Is multiple inheritance allowed in Java?
`No, Java does not allow multiple inheritance. In Java, a class can only inherit from a single superclass, and it cannot inherit from multiple classes.`

`This means that a class in Java cannot have more than one direct superclass, and it cannot inherit the behavior of multiple classes at the same time. However, a class can implement multiple interfaces, which allows it to reuse the behavior defined in those interfaces.`

`The decision to disallow multiple inheritance in Java was made to simplify the language and avoid the complexity and ambiguity that can arise when a class inherits from multiple superclasses. Multiple inheritance can lead to problems such as the "diamond problem", where a subclass inherits conflicting behavior from multiple superclasses, and it is not clear which behavior should take precedence.`

`To achieve the benefits of multiple inheritance in Java, you can use interfaces, which allow a class to implement multiple abstract behaviors. This allows you to define a set of related behaviors that can be shared by multiple classes, without the complexity and ambiguity of multiple inheritance.`

`Here is an example of a class that implements multiple interfaces in Java:`

```
public class MyClass implements Interface1, Interface2 {
   // Implementation of the methods defined in Interface1 and Interface2
}
```
`In summary, multiple inheritance is not allowed in Java, but you can use interfaces to achieve many of the same benefits. This allows you to define a set of related behaviors that can be shared by multiple classes, without the complexity and ambiguity of multiple inheritance.`
### What is a static class member?
`In Java, a static class member is a field or method that is shared by all instances of a class. A static member is associated with the class itself, rather than with individual objects of the class.`

`To create a static class member in Java, you use the static modifier when declaring the member. A static field is a class-level variable that is shared by all objects of the class, and a static method is a class-level method that can be called without an instance of the class.`

`Here is an example of a static field and a static method in Java:`

```
public class MyClass {
   private static int counter = 0;

   public static void incrementCounter() {
      counter++;
   }
}
```
`In this example, the counter field is a static field, and the incrementCounter method is a static method. The counter field is shared by all objects of the MyClass class, and the incrementCounter method can be called using the name of the class, rather than an instance of the class.`

`Here is an example of how to access a static member in Java:`

```
MyClass.counter = 10;
MyClass.incrementCounter();
int c = MyClass.counter;
```
`In this example, the counter field is accessed using the name of the class, and the incrementCounter method is called using the name of the class.`

`Static members are useful when you need to define behavior or data that is shared by all objects of a class. They are also useful for creating utility methods that do not need to operate on specific objects, but can be called using the name of the class. However, it is important to use static members judiciously, as they can make your code more difficult to understand.`
### Can a static method use non-static members?
`No, a static method in Java cannot directly access non-static members of the class. This is because a static method is associated with the class itself, rather than with individual objects of the class.`

`A static method can only access static members of the class, because static members are associated with the class itself and are shared by all objects of the class. However, a static method cannot access non-static members of the class, because non-static members are associated with individual objects, and a static method does not have a reference to a specific object.`

`Here is an example of a static method that cannot access a non-static member in Java:`

```
public class MyClass {
   private int counter = 0;

   public static void incrementCounter() {
      counter++; // This will cause a compile-error
   }
}
```
`In this example, the incrementCounter method is a static method, and the counter field is a non-static field. The incrementCounter method cannot directly access the counter field, because it is not a static field.`

`To access a non-static field from a static method, you can either pass the field as an argument to the method, or you can create an instance of the class and use the instance to access the field. Here is an example of how to access a non-static field from a static method:`

```
public class MyClass {
   private int counter = 0;

   public static void incrementCounter(MyClass obj) {
      obj.counter++;
   }
}

// ...

MyClass obj = new MyClass();
MyClass.incrementCounter(obj);
```
`In this example, the incrementCounter method is a static method, and the counter field is a non-static field. The incrementCounter method takes an instance of the MyClass class as an argument, and it uses the instance to access the counter field.`

`Overall, it is important to understand the differences between static and non-static members in Java, and to use them appropriately in your code. Static members are useful for defining behavior or data that is shared by all objects of a class, but they cannot directly access non-static members of the class.`
### What does the final keyword mean in Java?
`In Java, the final keyword has several different meanings, depending on the context in which it is used.`

- `final variables: When used with a variable, the final keyword indicates that the value of the variable cannot be modified after it is initialized. A final variable must be initialized at the time it is declared, and it cannot be changed later. This can be useful for creating constants or for ensuring that the value of a variable does not change unexpectedly.`
`Here is an example of a final variable in Java:`

```
final int MAX_VALUE = 100;
```
`In this example, the MAX_VALUE variable is a final int with a value of 100. It cannot be modified after it is initialized, and any attempt to do so will result in a compile-error.`

- `final methods: When used with a method, the final keyword indicates that the method cannot be overridden by a subclass. A final method is considered to be a "fixed" part of the class, and it cannot be changed or extended by subclasses. This can be useful for ensuring that the behavior of a method is not modified by subclasses.`
`Here is an example of a final method in Java:`

```
public final void doSomething() {
   // Method implementation
}
```
`In this example, the doSomething method is a final method that cannot be overridden by a subclass. Any attempt to override the method in a subclass will result in a compile-error.`

- `final classes: When used with a class, the final keyword indicates that the class cannot be subclassed. A final class is considered to be a "complete" class, and it cannot be extended by other classes. This can be useful for ensuring that the behavior of a class is not modified by subclasses.`
`Here is an example of a final class in Java:`
```
public final class MyClass {
   // Class implementation
}
```
`In this example, the MyClass class is a final class that cannot be subclassed. Any attempt to subclass MyClass will result in a compile-error.`

`Overall, the final keyword is a useful tool in Java that allows you to create variables, methods, and classes that cannot be modified or extended. It is an important part of the object-oriented programming paradigm in Java, and it is used to enforce encapsulation and prevent unintended changes to your code.`
### What does the abstract keyword mean in Java?
`In Java, the abstract keyword is used to define an abstract class or an abstract method.`

- `abstract classes: An abstract class is a class that cannot be instantiated, and it is used to define a common set of behaviors that can be shared by multiple classes. An abstract class can contain both abstract methods (methods without an implementation) and concrete methods (methods with an implementation). A class that extends an abstract class must implement all of the abstract methods defined in the abstract class, or it must also be declared as abstract.`

- `abstract methods: An abstract method is a method that does not have an implementation, and it must be implemented by a subclass. An abstract method is defined with the abstract keyword and does not have a body. A class that contains abstract methods must also be declared as abstract.`

`Overall, the abstract keyword is an important part of the object-oriented programming paradigm in Java, and it is used to define common behavior that can be shared by multiple classes. It allows you to create a hierarchy of classes that share common behavior, and it enables you to define a set of related behaviors that can be implemented in different ways by different classes.`
### What is overloading in Java?
`In Java, overloading is a mechanism that allows you to define multiple methods with the same name, but with different parameter lists. This allows you to create methods that have the same name, but that can be called with different sets of arguments, and that can perform different actions depending on the arguments.`

`To overload a method in Java, you define multiple methods with the same name, but with different parameter lists. The parameter list includes the number and types of the arguments that the method can accept. When you call an overloaded method, Java uses the parameter list to determine which version of the method to call.`

`Overloading can be a useful way to provide multiple versions of a method that can be called in different situations. It allows you to define a single interface for a method, but to provide multiple implementations that can be selected at runtime based on the arguments passed to the method.`

`Overall, overloading is an important part of the object-oriented programming paradigm in Java, and it allows you to create flexible and reusable methods that can be called with different sets of arguments. It is an important part of the Java language, and it is used in many Java programs to provide multiple versions of a method that can be called depending on the context.`

```
public class MyClass {
   // Overloaded method with a single int argument
   public void print(int value) {
      System.out.println("The value is: " + value);
   }

   // Overloaded method with a single String argument
   public void print(String value) {
      System.out.println("The value is: " + value);
   }

   // Overloaded method with two int arguments
   public int add(int a, int b) {
      return a + b;
   }

   // Overloaded method with two double arguments
   public double add(double a, double b) {
      return a + b;
   }
}

```
`In this example, the MyClass class defines four overloaded methods: print and add. The print method is overloaded with two different versions: one that takes an int argument and one that takes a String argument. The add method is overloaded with two different versions: one that takes two int arguments and one that takes two double arguments.`

`To call an overloaded method, you use the same method name, but you pass different arguments depending on which version of the method you want to call. For example:`
```
MyClass obj = new MyClass();

// Call the int version of the print method
obj.print(123);

// Call the String version of the print method
obj.print("Hello, world!");

// Call the int version of the add method
int sum1 = obj.add(1, 2);

// Call the double version of the add method
double sum2 = obj.add(1.5, 2.5);

```
`In this example, the print method is called with two different sets of arguments, and the add method is called with two different sets of arguments. Java will select the appropriate version of each method based on the types of the arguments passed to the method.`
### What is overriding in Java?
`In Java, overriding is a mechanism that allows a subclass to provide a new implementation for a method that is inherited from a superclass. This allows you to change or extend the behavior of a method in a subclass, while still maintaining the same method signature.`

`To override a method in Java, you define a new method with the same name, return type, and parameter list as the method in the superclass. The subclass method must also be marked with the @Override annotation, which indicates that the method is intended to override a superclass method.`

`Here is an example of overriding in Java:`

```
public class SuperClass {
   public void doSomething() {
      System.out.println("Doing something in the superclass");
   }
}

public class SubClass extends SuperClass {
   @Override
   public void doSomething() {
      System.out.println("Doing something in the subclass");
   }
}
```
`In this example, the SuperClass defines a method called doSomething, and the SubClass extends the SuperClass and overrides the doSomething method. When you call the doSomething method on an instance of the SubClass, it will use the implementation defined in the SubClass, rather than the implementation defined in the SuperClass.`

`Overriding is an important part of the object-oriented programming paradigm in Java, and it allows you to create a hierarchy of classes that share common behavior, but that can also override or extend the behavior in specific cases. It is an important part of the Java language, and it is used in many Java programs to provide a flexible and reusable way to change or extend the behavior of a method.`
### What is the difference between overloading and overriding?
`In Java, overloading and overriding are two different mechanisms that allow you to define multiple methods with the same name. However, they are used for different purposes, and they have some important differences.`

- `Overloading: Overloading is a mechanism that allows you to define multiple methods with the same name, but with different parameter lists. This allows you to create methods that have the same name, but that can be called with different sets of arguments, and that can perform different actions depending on the arguments. To overload a method in Java, you define multiple methods with the same name, but with different parameter lists. The parameter list includes the number and types of the arguments that the method can accept.`

- `Overriding: Overriding is a mechanism that allows a subclass to provide a new implementation for a method that is inherited from a superclass. This allows you to change or extend the behavior of a method in a subclass, while still maintaining the same method signature. To override a method in Java, you define a new method with the same name, return type, and parameter list as the method in the superclass. The subclass method must also be marked with the @Override annotation, which indicates that the method is intended to override a superclass method.`

`Overall, overloading and overriding are two different mechanisms that allow you to define multiple methods with the same name. Overloading is used to create multiple versions of a method that can be called with different sets of arguments, while overriding is used to provide a new implementation for a method that is inherited from a superclass. They are both important parts of the object-oriented programming paradigm in Java, and they are used in many Java programs to provide flexible and reusable ways to define and modify the behavior of methods.`
### What is null?
`In Java, null is a special value that represents the absence of a value or a reference. It can be assigned to any reference type, such as an object reference, an array reference, or a class reference.`

`Here is an example of using null in Java:`

```
String s = null;
```
`In this example, the s variable is a reference to a String object, and it is initialized with the value null. This means that the s variable does not currently refer to any String object.`

`It is important to note that null is not the same as an empty string, and it is not the same as a string with no characters. An empty string is a string object with a length of 0, while null represents the absence of a reference to an object.`

`You can test for null using the == operator or the != operator, like this:`

```
if (s == null) {
   // s is null
}

if (s != null) {
   // s is not null
}
```
`Overall, null is an important concept in Java, and it is used to represent the absence of a value or a reference. It is an important part of the Java language, and it is used in many Java programs to represent the absence of a value or a reference.`
### Compare the access modifiers in Java.
`In Java, access modifiers are keywords that are used to specify the accessibility of a class, field, method, or constructor. There are four access modifiers in Java:`

- `public: When a class, field, method, or constructor is marked as public, it can be accessed from anywhere in the program.`

- `private: When a class, field, method, or constructor is marked as private, it can only be accessed within the class in which it is declared.`

- `protected: When a class, field, method, or constructor is marked as protected, it can be accessed within the class in which it is declared and its subclasses.`

- `default (also known as package-private): When a class, field, method, or constructor has no access modifier specified, it is marked as default, which means it can be accessed within the package in which it is declared.`

`Here is an example that demonstrates the use of access modifiers in Java:`

```
public class MyClass {
  private int x; // x can only be accessed within MyClass
  protected int y; // y can be accessed within MyClass and its subclasses
  int z; // z can be accessed within the package in which MyClass is declared
  public int w; // w can be accessed from anywhere

  private void privateMethod() {
    // privateMethod can only be called within MyClass
  }

  protected void protectedMethod() {
    // protectedMethod can be called within MyClass and its subclasses
  }

  void defaultMethod() {
    // defaultMethod can be called within the package in which MyClass is declared
  }

  public void publicMethod() {
    // publicMethod can be called from anywhere
  }
}
```
### What is the default access modifier in a class?
`In Java, if you do not specify an access modifier for a class, it is marked as default, also known as package-private. This means that the class can only be accessed within the package in which it is declared.`

`For example:`

```
package com.example;

class MyClass {
  // MyClass is marked as default (package-private)
  // It can only be accessed within the com.example package
}
```
`Note that the default access modifier is not the same as the public access modifier. A class marked as public can be accessed from anywhere in the program, whereas a class marked as default can only be accessed within the package in which it is declared.`

```
package com.example;

public class MyClass {
  // MyClass is marked as public
  // It can be accessed from anywhere in the program
}
```
### What is the purpose of the ‘equals()’ method?
`The equals() method in Java is a method of the Object class that is used to determine whether two objects are equal. The equals() method compares the object references of two objects to determine if they are the same object.`

`By default, the equals() method in the Object class compares the object references of two objects to determine if they are the same object. This means that if you have two objects with the same contents but are stored in different locations in memory, the equals() method will return false.`

`For example:`

```
Object obj1 = new Object();
Object obj2 = new Object();
System.out.println(obj1.equals(obj2)); // Outputs "false"
```
`However, you can override the equals() method in a subclass to implement your own definition of object equality. For example, you might want to define two objects as equal if they have the same contents, regardless of where they are stored in memory.`

`Here is an example of how you can override the equals() method in a subclass:`

```
class MyClass {
  private int value;

  public MyClass(int value) {
    this.value = value;
  }

  @Override
  public boolean equals(Object o) {
    if (o instanceof MyClass) {
      MyClass other = (MyClass) o;
      return this.value == other.value;
    }
    return false;
  }
}
```
`In this example, the equals() method compares the value field of the two objects to determine if they are equal.`

`It is generally a good practice to override the equals() method whenever you create a new class that represents a data structure or entity, so that you can compare objects of that class based on their contents rather than their object references.`
### What is the difference between '==' and 'equals()'?
`In Java, the == operator is used to compare the values of two primitive data types (such as int, char, etc.) or to compare two object references to see if they refer to the same object.`

`The equals() method, on the other hand, is a method of the Object class that is used to determine whether two objects are equal. By default, the equals() method in the Object class compares the object references of two objects to determine if they are the same object.`

`Here is an example that demonstrates the difference between == and equals():`

```
// Compare the values of two int variables using the == operator
int x = 10;
int y = 20;
System.out.println(x == y); // Outputs "false"

// Compare two String objects using the == operator
String s1 = new String("Hello");
String s2 = new String("Hello");
System.out.println(s1 == s2); // Outputs "false"

// Compare two String objects using the equals() method
System.out.println(s1.equals(s2)); // Outputs "true"
```
- `In the first example, the == operator is used to compare the values of two int variables. In this case, x and y have different values, so the == operator returns false.`

- `In the second example, the == operator is used to compare two String objects. In this case, s1 and s2 are different objects that have the same contents, so the == operator returns false.`

- `In the third example, the equals() method is used to compare the contents of s1 and s2, which are both equal to "Hello". In this case, the equals() method returns true.`

`As a general rule, you should use the == operator to compare primitive data types and the equals() method to compare objects. However, keep in mind that you can override the equals() method in a subclass to implement your own definition of object equality.`
### What is the difference between long and Long?
`In Java, long is a primitive data type that represents a 64-bit two's complement integer. Long is a wrapper class that represents a long value as an object.`

`Here is an example that demonstrates the difference between long and Long:`

```
long x = 10; // x is a long primitive
Long y = 20L; // y is a Long object

System.out.println(x + y); // Outputs "30"
```
`In this example, x is a long primitive and y is a Long object. The + operator automatically converts the long primitive to a Long object and performs the addition.`

`There are a few key differences between long and Long:`

- `long is a primitive data type, while Long is an object. This means that long values are stored directly in the memory, while Long objects are stored on the heap and accessed through references.`

- `long values cannot be null, while Long objects can be null.`

- `long values do not have any methods, while Long objects have a number of useful methods, such as longValue(), compareTo(), and valueOf().`

`In general, you should use long for primitive values and Long for objects. However, keep in mind that you can use long values wherever an Object is expected, since long values are automatically boxed to Long objects.`
### Which can store bigger numbers, `long` or `Long`?
`In Java, both long and Long can store numbers in the range of -2^63 to 2^63-1, which is a very large range. Therefore, both long and Long can store very large numbers.`
### What kind of packages do you know under java.util.* ? Bring at least 3 examples.
`The java.util package is a package in the Java Standard Library that contains a number of useful utility classes and interfaces. Some examples of packages under java.util include:`

- `java.util.Arrays: This package contains static methods for manipulating arrays, such as sort(), binarySearch(), and copyOf().`

- `java.util.Collections: This package contains static utility methods for working with collections, such as sort(), reverse(), and shuffle(). It also contains a number of classes that implement common collection interfaces, such as ArrayList, LinkedList, and HashSet.`

- `java.util.Scanner: This class provides a convenient way to read input from the console or from a file. It can read various types of data, such as integers, floating-point numbers, and strings.`

`Here is an example that demonstrates how you can use some of the classes and methods in these packages:`

```
import java.util.Arrays;
import java.util.Collections;
import java.util.Scanner;

public class Main {
  public static void main(String[] args) {
    // Use the Arrays.sort() method to sort an array of integers
    int[] numbers = {3, 1, 2};
    Arrays.sort(numbers);
    System.out.println(Arrays.toString(numbers)); // Outputs "[1, 2, 3]"

    // Use the Collections.reverse() method to reverse the order of a list
    List<String> words = Arrays.asList("apple", "banana", "cherry");
    Collections.reverse(words);
    System.out.println(words); // Outputs "[cherry, banana, apple]"

    // Use the Scanner class to read input from the console
    Scanner scanner = new Scanner(System.in);
    System.out.print("Enter a number: ");
    int num = scanner.nextInt();
    System.out.println("You entered: " + num);
  }
}
```
## Collections

### What is the Iterable interface?
`The Iterable interface is an interface in the Java Standard Library that represents an object that can be iterated over. It is a member of the java.lang package and is implemented by classes that can provide an iterator over their elements.`

`The Iterable interface has a single method, iterator(), which returns an Iterator object that can be used to iterate over the elements in the Iterable object.`

`Here is an example that demonstrates how you can use the Iterable interface to iterate over the elements in a list:`

```
import java.util.List;
import java.util.ArrayList;

public class Main {
  public static void main(String[] args) {
    List<String> words = new ArrayList<>();
    words.add("apple");
    words.add("banana");
    words.add("cherry");

    // The List class implements the Iterable interface
    // So we can use a for-each loop to iterate over the elements in the list
    for (String word : words) {
      System.out.println(word);
    }
  }
}
```
`In this example, the words list is an object of the ArrayList class, which implements the Iterable interface. This means that we can use a for-each loop to iterate over the elements in the list. The for-each loop calls the iterator() method of the words list to obtain an Iterator object, and then it calls the hasNext() and next() methods of the Iterator object to iterate over the elements in the list.`

`It is important to note that the Iterable interface is a generic interface, so you can specify the type of the elements that the Iterable object contains. In the example above, we have specified that the Iterable object contains String elements.`
### What is the Collection interface?
`In the Java programming language, the Collection interface is a member of the Java Collections Framework. It is an interface that defines the operations that can be performed on a collection of objects.`

`A Collection is an object that represents a group of objects, known as its elements. Some examples of collections in Java are lists, sets, and queues. The Collection interface defines the basic operations that can be performed on all collections, such as adding and removing elements, and iterating over the elements in the collection.`

`The Collection interface extends the Iterable interface, which means that all collections can be iterated over using the for-each loop or an iterator. The Collection interface also defines several default methods, which are methods that have a default implementation in the interface itself and can be overridden by implementing classes.`

`Here is an example of how to use the Collection interface in Java:`

```
import java.util.Collection;
import java.util.ArrayList;

public class CollectionExample {
    public static void main(String[] args) {
        Collection<String> collection = new ArrayList<>();
        collection.add("apple");
        collection.add("banana");
        collection.add("cherry");

        for (String s : collection) {
            System.out.println(s);
        }

        collection.remove("banana");
        System.out.println("Size of collection: " + collection.size());
    }
}
```
```
Output:

Copy code
apple
banana
cherry
Size of collection: 2
```


### What is the Map interface?
`In the Java programming language, the Map interface is a member of the Java Collections Framework. It is an interface that represents a mapping between a key and a value. A Map is an object that stores associations between keys and values. Each key is unique and is used to retrieve the corresponding value.`

`The Map interface defines the basic operations that can be performed on all maps, such as adding and removing key-value pairs, and iterating over the keys and values in the map. The Map interface extends the Collection interface, which means that it can be treated as a collection of keys, values, or key-value pairs.`

`The Map interface has two subinterfaces: SortedMap and NavigableMap. SortedMap is a Map that maintains its entries in ascending key order, and NavigableMap is a SortedMap that provides convenient navigation methods.`

`Here is an example of how to use the Map interface in Java:`

```
import java.util.Map;
import java.util.HashMap;

public class MapExample {
    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();
        map.put("apple", 1);
        map.put("banana", 2);
        map.put("cherry", 3);

        for (Map.Entry<String, Integer> entry : map.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }

        map.remove("banana");
        System.out.println("Size of map: " + map.size());
    }
}
```
`Output:`
```
apple: 1
banana: 2
cherry: 3
Size of map: 2
```
### Compare sets, lists, and queues in Java.
`In the Java programming language, sets, lists, and queues are all implementations of the Collection interface. They are data structures that store a group of objects, known as elements. Each type of collection has its own characteristics and is suitable for different purposes.`

- `Sets are collections that do not allow duplicate elements and do not have a specific order. They are useful when you need to store a group of unique elements and do not care about the order in which they are stored. The Java Collections Framework provides several implementations of the Set interface, such as HashSet, TreeSet, and LinkedHashSet.`

- `Lists are collections that allow duplicate elements and maintain a specific order. They are useful when you need to store a group of elements and need to maintain their order. The Java Collections Framework provides several implementations of the List interface, such as ArrayList, LinkedList, and Vector.`

- `Queues are collections that are designed for holding elements prior to processing. They are typically used when you need to store elements temporarily while waiting for them to be processed. The Java Collections Framework provides several implementations of the Queue interface, such as ArrayDeque and LinkedList.`

`Here is an example that demonstrates the difference between sets, lists, and queues in Java:`

```
import java.util.Set;
import java.util.HashSet;
import java.util.List;
import java.util.ArrayList;
import java.util.Queue;
import java.util.LinkedList;

public class CollectionComparison {
    public static void main(String[] args) {
        Set<String> set = new HashSet<>();
        set.add("apple");
        set.add("banana");
        set.add("cherry");
        set.add("apple"); // duplicate element, not added to set
        System.out.println("Set: " + set);

        List<String> list = new ArrayList<>();
        list.add("apple");
        list.add("banana");
        list.add("cherry");
        list.add("apple"); // duplicate element, added to list
        System.out.println("List: " + list);

        Queue<String> queue = new LinkedList<>();
        queue.add("apple");
        queue.add("banana");
        queue.add("cherry");
        System.out.println("Queue: " + queue);
        queue.poll(); // remove and return the head of the queue
        System.out.println("Queue: " + queue);
    }
}
```
`Output:`

```
Set: [apple, banana, cherry]
List: [apple, banana, cherry, apple]
Queue: [apple, banana, cherry]
Queue: [banana, cherry]
```
### Compare ArrayList and LinkedList in Java.
`In the Java programming language, ArrayList and LinkedList are both implementation classes of the List interface. They are both used to store a group of elements in a specific order, but they have some differences in terms of their internal implementation and performance.`

- `ArrayList is implemented using an array data structure and is backed by an array. It has fast random access to elements, but inserting or deleting elements at the beginning or middle of the list can be slow because it requires shifting the elements to make room for the new element or close the gap left by the deleted element.`

- `LinkedList is implemented using a linked list data structure and is backed by a double-linked list. It has slow random access to elements, but inserting or deleting elements at the beginning or middle of the list is fast because it only requires changing the pointers of the adjacent nodes.`

`Here is an example that demonstrates the difference between ArrayList and LinkedList in Java:`

```
import java.util.List;
import java.util.ArrayList;
import java.util.LinkedList;

public class ListComparison {
    public static void main(String[] args) {
        List<Integer> arrayList = new ArrayList<>();
        arrayList.add(1);
        arrayList.add(2);
        arrayList.add(3);
        arrayList.add(1, 4); // insert element at index 1
        System.out.println("ArrayList: " + arrayList);

        List<Integer> linkedList = new LinkedList<>();
        linkedList.add(1);
        linkedList.add(2);
        linkedList.add(3);
        linkedList.add(1, 4); // insert element at index 1
        System.out.println("LinkedList: " + linkedList);
    }
}
```
`Output:`
```
ArrayList: [1, 4, 2, 3]
LinkedList: [1, 4, 2, 3]
```
`As you can see, both ArrayList and LinkedList can insert an element at a specific index, but the performance of the operation may differ depending on the implementation. ArrayList has to shift the elements to make room for the new element, while LinkedList only has to change the pointers of the adjacent nodes.`
### Are sets sorted in Java?
`In the Java programming language, sets are collections that do not allow duplicate elements and do not have a specific order. The order of the elements in a set is not specified and may change as elements are added or removed.`

`However, the Java Collections Framework provides a subinterface of the Set interface called SortedSet, which is a set that maintains its elements in ascending order, according to the natural ordering of its elements or according to a Comparator provided at the time of creation.`

`Here is an example of how to use the SortedSet interface in Java:`

```
import java.util.SortedSet;
import java.util.TreeSet;

public class SortedSetExample {
    public static void main(String[] args) {
        SortedSet<String> set = new TreeSet<>();
        set.add("apple");
        set.add("banana");
        set.add("cherry");
        System.out.println("SortedSet: " + set);
    }
}
```
`Output:`
```
SortedSet: [apple, banana, cherry]
```
`As you can see, the elements in the set are automatically sorted in ascending order according to their natural ordering (alphabetical order in this case).`

`If you want to create a SortedSet with a custom Comparator, you can use the following code:`

```
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.Comparator;

public class SortedSetExample {
    public static void main(String[] args) {
        SortedSet<Integer> set = new TreeSet<>(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o2 - o1; // sort in descending order
            }
        });
        set.add(3);
        set.add(1);
        set.add(2);
        System.out.println("SortedSet: " + set);
    }
}
```
`Output:`
```
SortedSet: [3, 2, 1]
```
`As you can see, the elements in the set are now sorted in descending order according to the custom Comparator.`

## Design Principles

### Explain the Single Responsibility Principle.
`The Single Responsibility Principle (SRP) is a software design principle that states that every class or module should have a single responsibility, or a single reason to change. This means that a class or module should have a well-defined role and should be responsible for only a single part of the functionality of the system.`

`The main benefit of following the Single Responsibility Principle is that it leads to more modular and maintainable code. By dividing the system into smaller, independent units with a single responsibility, it becomes easier to understand, test, and modify the code. It also reduces the risk of introducing errors or breaking existing functionality when making changes to the code.`

`Here are some guidelines for applying the Single Responsibility Principle:`

`Identify the responsibilities of a class or module and ensure that it has only one.
Avoid creating classes that are too big or too complex, and instead divide them into smaller, more focused classes.
Avoid creating classes that depend on too many other classes or have too many dependencies.
Avoid creating classes that perform multiple unrelated tasks.
Here is an example of how the Single Responsibility Principle can be applied in the design of a class:`

`Suppose you are designing a class to represent a car. A car has several responsibilities, such as starting the engine, stopping the engine, changing gears, and accelerating.`

`According to the Single Responsibility Principle, it would be better to create separate classes for each of these responsibilities, rather than putting all of the code in a single Car class. This would result in more modular and maintainable code.`

`For example, you could create a class called Engine to handle the starting and stopping of the engine, a class called Transmission to handle the changing of gears, and a class called Accelerator to handle the acceleration. The Car class would then delegate these responsibilities to the appropriate class.`

```
public class Car {
    private Engine engine;
    private Transmission transmission;
    private Accelerator accelerator;

    public Car() {
        engine = new Engine();
        transmission = new Transmission();
        accelerator = new Accelerator();
    }

    public void startEngine() {
        engine.start();
    }

    public void stopEngine() {
        engine.stop();
    }

    public void changeGears(int gear) {
        transmission.changeGears(gear);
    }

    public void accelerate(int speed) {
        accelerator.accelerate(speed);
    }
}
```
`By following the Single Responsibility Principle, you can create a more modular and maintainable design for your class.`
### Explain the Interface Segregation Principle.
`The Interface Segregation Principle (ISP) is a software design principle that states that clients should not be forced to depend on interfaces they do not use. This means that an interface should be fine-grained and should contain only the methods that are relevant to the clients that use it.`

`The main benefit of following the Interface Segregation Principle is that it leads to more flexible and adaptable code. By creating small, specialized interfaces that contain only the methods that are needed by specific clients, it becomes easier to modify the code without affecting unrelated clients. It also reduces the risk of introducing errors or breaking existing functionality when making changes to the code.`

`Here are some guidelines for applying the Interface Segregation Principle:`

- `Avoid creating large, monolithic interfaces that contain a lot of methods that are not used by all clients.`
- `Divide large interfaces into smaller, more specialized interfaces that contain only the methods that are relevant to specific clients.`
- `Avoid creating interfaces that contain methods that are unrelated to each other.`
- `Avoid creating interfaces that contain methods that are optional for some clients and required for others.
Here is an example of how the Interface Segregation Principle can be applied in the design of an interface:`

`Suppose you are designing an interface to represent a shape. A shape has several responsibilities, such as calculating its area, calculating its perimeter, and drawing itself.`

`According to the Interface Segregation Principle, it would be better to create separate interfaces for each of these responsibilities, rather than putting all of the methods in a single Shape interface. This would result in a more flexible and adaptable design.`

`For example, you could create an interface called AreaCalculator to handle the calculation of the area, an interface called PerimeterCalculator to handle the calculation of the perimeter, and an interface called Drawable to handle the drawing of the shape. The Shape interface would then extend these interfaces.`

```
public interface AreaCalculator {
    double calculateArea();
}

public interface PerimeterCalculator {
    double calculatePerimeter();
}

public interface Drawable {
    void draw();
}

public interface Shape extends AreaCalculator, PerimeterCalculator, Drawable {
}
```
`By following the Interface Segregation Principle, you can create a more flexible and adaptable design for your interface. Clients that only need to calculate the area or perimeter of a shape can depend on the appropriate interface, without being forced to depend on the methods in the Drawable interface.`
### What is composition over inheritance?
`Composition over inheritance is a design principle that suggests that it is better to use composition, or the combining of simple objects to create more complex ones, rather than inheritance, or the creation of a new class by inheriting from an existing class.`

`The main advantage of composition over inheritance is that it allows for greater flexibility and reuse of code. With composition, you can create complex objects by combining simple objects that have already been defined, rather than creating a new class that inherits from an existing class and potentially modifying its behavior. This makes it easier to modify and extend the code, as you can change the behavior of a complex object by changing the simple objects it is composed of, rather than modifying the inherited class.`

`Composition also allows you to achieve code reuse by creating a single instance of a simple object and reusing it in multiple complex objects. This is in contrast to inheritance, where you would have to create a new instance of the inherited class for each object that needs to use it.`

`In general, composition over inheritance is preferred because it allows for greater flexibility and reuse of code, and it makes it easier to modify and extend the code. However, there are cases where inheritance may be more appropriate, such as when you need to override the behavior of an existing class or when you need to create a class that is a more specialized version of an existing class.`

`Here is an example of how composition can be used in Java to achieve code reuse and flexibility:`

```
public class Engine {
    public void start() {
        // start the engine
    }

    public void stop() {
        // stop the engine
    }
}

public class Transmission {
    public void changeGears(int gear) {
        // change the gears
    }
}

public class Car {
    private Engine engine;
    private Transmission transmission;

    public Car() {
        engine = new Engine();
        transmission = new Transmission();
    }

    public void start() {
        engine.start();
    }

    public void stop() {
        engine.stop();
    }

    public void changeGears(int gear) {
        transmission.changeGears(gear);
    }
}
```
`In this example, the Car class uses composition to reuse the code and behavior of the Engine and Transmission classes. This allows the Car class to start and stop the engine and change the gears, without inheriting from the Engine and Transmission classes. This makes the design more flexible and easier to change, because the Car class is not tightly coupled to the Engine and Transmission classes.`




### What is a model class?
`In the Java programming language, a model class is a class that represents a data model or domain model in an application. It typically contains fields that correspond to the attributes of the data model and methods that provide access to the data and perform operations on it.`

`Model classes are often used to represent the data that is stored in a database or other persistent storage, as well as the data that is displayed to the user or passed between different layers of an application. They are typically designed to be simple, self-contained, and easy to use, and they often follow the JavaBeans conventions, which specify a standard way of defining Java classes that can be used to represent data.`

`Model classes are often used in conjunction with other classes and components in an application, such as controllers, views, or service classes, to implement the business logic and manage the data flow between the different layers of the application. They can also be used to define the data structure and relationships of the data model, and to provide methods for querying, updating, and validating the data.`
### What is a service class?
`In the Java programming language, a service class is a class that provides a specific service or set of services to other classes or components in an application. Service classes are often used to implement the business logic of an application and to manage the data flow between the different layers of the application.`

`Service classes are typically designed to be self-contained and reusable, and they often provide a well-defined interface that other classes can use to access their services. They may also depend on other classes or components, such as model classes or data access objects, to provide data or perform specific tasks.`

`Service classes are typically used to encapsulate complex or repetitive logic that is needed by multiple parts of an application, and to provide a single point of access for this logic. This helps to keep the code organized and maintainable, and it allows other parts of the application to access the services provided by the service class without having to implement the logic themselves.`

`Service classes are often used in conjunction with other classes and components in an application, such as controllers, views, or model classes, to implement the overall architecture and design of the application. They can also be used to define the interactions and relationships between different parts of the application, and to provide a consistent interface for accessing the services provided by the application.`

```
import java.util.List;

public class StudentService {
    private StudentDao studentDao;

    public StudentService() {
        studentDao = new StudentDao();
    }

    public List<Student> getAllStudents() {
        return studentDao.getAllStudents();
    }

    public Student getStudentById(int id) {
        return studentDao.getStudentById(id);
    }

    public void addStudent(Student student) {
        studentDao.addStudent(student);
    }

    public void updateStudent(Student student) {
        studentDao.updateStudent(student);
    }

    public void deleteStudent(int id) {
        studentDao.deleteStudent(id);
    }
}
```
### How do you prevent developers from subclassing a class?
`There are several ways you can prevent developers from subclassing a class in the Java programming language:`

`Declare the class as final: By declaring a class as final, you can prevent any other class from extending it. This is the simplest and most straightforward way to prevent subclassing.`
```
public final class MyClass {
    // class implementation
}
```
`Make the class's constructor private: By making the class's constructor private, you can prevent other classes from creating instances of the class. This will effectively prevent subclassing, as a subclass would not be able to call the superclass's constructor.`
```
public class MyClass {
    private MyClass() {
        // private constructor
    }
}
```
`Use an abstract class: By making the class abstract, you can prevent it from being instantiated, but you can still allow other classes to extend it. This can be useful if you want to provide a basic implementation of some methods, but you want to allow other classes to provide more specialized implementations.`
```
public abstract class MyClass {
    // abstract class implementation
}
```
`Use a utility class: If the class only contains static methods and fields, you can consider making it a utility class. Utility classes are often used to provide a set of common functions or utilities that can be used by other parts of the application, and they are not intended to be subclassed.`
```
public class MyClass {
    private MyClass() {
        // private constructor to prevent instantiation
    }

    public static void doSomething() {
        // static method implementation
    }
}
```
`By using one of these techniques, you can prevent developers from subclassing a class in Java. However, it's important to note that these techniques should only be used when necessary, as they can limit the flexibility and extendability of the code.`
### How do you prevent developers from changing the value of a variable?
`There are several ways you can prevent developers from changing the value of a variable in the Java programming language:`

- `Declare the variable as final: By declaring a variable as final, you can prevent its value from being modified after it has been initialized.`

- `Make the variable private: By making the variable private, you can prevent other classes from accessing it directly. This can be useful if you want to control access to the variable through methods in the class.`

- `Use an immutable class: By creating an immutable class, you can prevent any changes to the values of the class's fields after the class has been constructed. Immutable classes are useful when you want to ensure that the state of an object does not change after it has been created.`

- `Use a thread-safe data structure: If you are working with concurrent programming, you can use a thread-safe data structure, such as a ConcurrentHashMap, to prevent multiple threads from modifying the same data simultaneously.`

- `Use a lock: If you need to fine-grained control over access to a variable, you can use a lock, such as a ReentrantLock, to synchronize access to the variable. This can be useful if you want to allow multiple threads to access the variable, but you want to prevent them from modifying it concurrently.`
## Unit testing

### Why is unit testing a good practice?
`Unit testing is a good practice in Java because it helps to ensure that the individual units of code in an application are working correctly. Unit testing involves writing and running small, isolated tests that verify the behavior of specific pieces of code, such as methods or classes.`

`There are several benefits to unit testing in Java:`

- `Improved code quality: By writing and running unit tests, you can catch defects and bugs in your code early on, which makes it easier to fix them and improve the overall quality of your code.`

- `Faster debugging: If you have a comprehensive suite of unit tests, you can use them to quickly identify the source of a problem when debugging your code. This can save a lot of time and effort compared to manually testing the code.`

- `Enhanced maintainability: By writing unit tests for your code, you can ensure that any changes you make to the code do not break existing functionality. This can make it easier to maintain and evolve the code over time.`

- `Greater confidence: By having a large number of unit tests that cover different scenarios and edge cases, you can have greater confidence in the stability and reliability of your code.`

`Overall, unit testing is a good practice in Java because it helps to improve the quality, maintainability, and reliability of your code, and it can save a lot of time and effort in the long run.`
## What is JUnit?
`JUnit is a popular unit testing framework for the Java programming language. It is used to write and run small, isolated tests that verify the behavior of specific pieces of code, such as methods or classes.`

`JUnit provides a set of annotations and utility classes that make it easy to write and run tests. It also provides a variety of assertion methods that can be used to verify the expected behavior of the code being tested.`

`Here is an example of a simple JUnit test in Java:`

```
import org.junit.Test;
import static org.junit.Assert.*;

public class MyClassTest {
    @Test
    public void testAdd() {
        MyClass myClass = new MyClass();
        int result = myClass.add(1, 2);
        assertEquals(3, result);
    }
}
```
`In this example, the MyClassTest class contains a test method that verifies the behavior of the add() method in the MyClass class. The test method uses the assertEquals() method from JUnit to verify that the result of the add() method is as expected.`

`JUnit is widely used in the Java community and is a key part of many Java development processes. It is often used in conjunction with other tools and libraries, such as Maven or Gradle, to automate the testing and build processes.`

